# トランザクション制御

## トランザクション
- 「トランザクション（Transaction）」という言葉自体は「取引」や「決済」という意味で、一般的なビジネス用語としても使われているが、ITの世界におけるトランザクションは一般的に「データベースに対する更新処理を含む不可分な一連の処理」を表す
![](https://paper-attachments.dropbox.com/s_97DB13A37AEFF282FDE7C8C407E2A651907B7247430185934EA45818D080342A_1559071474136_.png)

## 
## トランザクションのコミットとロールバック
- トランザクションを構成するすべての処理が問題なく成功すれば、トランザクション全体を「確定」させる必要があり、この確定を「コミット（Commit）」と呼ぶ
![](https://paper-attachments.dropbox.com/s_97DB13A37AEFF282FDE7C8C407E2A651907B7247430185934EA45818D080342A_1559071780824_+.png)



- トランザクションを構成する処理のうち1つでも失敗すれば、トランザクション全体を「取り消す必要があり、この取り消しを「ロールバック（Rollback）」と呼ぶ
![](https://paper-attachments.dropbox.com/s_97DB13A37AEFF282FDE7C8C407E2A651907B7247430185934EA45818D080342A_1559072015863_+.png)



- したがってトランザクションは、成功して「コミット」されるか、失敗して「ロールバック」されるかの何れかであり、これは[ACID](https://ja.wikipedia.org/wiki/ACID_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E7%A7%91%E5%AD%A6))における「Atomicity」に相当する


## トランザクションの並行処理において発生する事象と可能性のある問題

複数のトランザクションが並行で実行される場合、以下のような事象が発生する可能性があり、データの整合性や一貫性に関する問題を生じることがある


- Dirty Read
    - クエリ実行時に、他のトランザクションによって更新された未コミットのデータを読み込んでしまう事象
    - この事象が発生すると、更新されたデータがロールバックされてしまうとデータの不整合が生じる可能性がある
- Non-Repeatable Read
    - トランザクション内で同一クエリを続けて実行する際に、他のトランザクションによって更新されたコミット済みデータを読み込んでしまう事象
    - この事象が発生すると、連続する同一クエリにおける結果に一貫性がなくなり、結果としてデータの不整合が生じる可能性がある
- Phantom Read
    - トランザクション内で同一クエリを続けて実行する際に、他のトランザクションによって挿入/削除されたレコードを読み込んでしまう/読み込めない事象
    - この事象が発生すると、連続する同一クエリにおける結果に一貫性がなくなり、結果としてデータの不整合が生じる可能性がある

上記のような事象や問題を防ぐためにANSI/ISO SQL標準では4段階の[トランザクション分離レベル](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E5%88%86%E9%9B%A2%E3%83%AC%E3%83%99%E3%83%AB)を規定しおり、それぞれのレベルにおいて上記のような問題の発生可能性の有無がわかる

**トランザクション分離レベルと発生する可能性のある問題**

|                  | DR    | NRR   | PR    |
| ---------------- | ----- | ----- | ----- |
| Read Uncommitted | 発生する  | 発生する  | 発生する  |
| Read Committed   | 発生しない | 発生する  | 発生する  |
| Repetable Read   | 発生しない | 発生しない | 発生する  |
| Serializable     | 発生しない | 発生しない | 発生しない |


**整合性とパフォーマンスのトレードオフ**

- 各トランザクション分離レベルにおけるデータの整合性や一貫性は「Read Uncommitted」が最も低く、「Serializable」が最も高いが、反対にパフォーマンス（性能）は「Serializable」が最も低く、「Read Uncommitted」が最も高い
- したがってシステム要件に応じて、適切にトランザクション分離レベルを設定する必要がある
- RDBMSによって、デフォルトやサポートしているトランザクション分離レベルは異なるが、一般的には「Read Committed」がデフォルトとなっている製品が多い
    - MariaDB/MySQLのデフォルトは「Repeatable Read」となっている


## トランザクション分離レベルの確認
- トランザクション制御の挙動はRDBMSのトランザクション分離レベルに依存するため、トランザクション制御を行う場合には現在のRDBMS環境設定を確認しておく必要がある
- 通常、RDBMSの環境設定では「Global」と「Session」という2つの概念がある
    - Global ･･･ そのRDBMS全体で有効な環境設定であり、新規に接続するすべてのクライアントで共通の設定
    - Session ･･･ 現在接続中の特定のクライアントのみ有効な環境設定であり、他の接続クライアントには影響を与えない（切断すればリセットされる）


- MariaDBでは専用の環境変数を使用して値が設定されており、この環境変数を確認するには「`[SHOW VARIABLES](https://dev.mysql.com/doc/refman/5.6/ja/show-variables.html)`」ステートメントを使用する

基本構文

    SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE 'pattern' | WHERE expr]

例）すべてのSession環境変数を確認

    show variables;

多くの環境変数が設定されていることがわかるが、特定の環境変数の値を確認するには `like` 句や `where` 句を使用して結果の絞り込みを行う

トランザクション分離レベルの値は「`tx_isolation`」変数に格納されているため、以下のように確認

例）トランザクション分離レベルの設定値を確認

    show variables like 'tx_isolation'; # 'tx%' でもOK
    +---------------+-----------------+
    | Variable_name | Value           |
    +---------------+-----------------+
    | tx_isolation  | REPEATABLE-READ |
    +---------------+-----------------+

もしくは変数名に接頭辞「`@@`」を付けて `SELECT` 文でも確認可能

    select @@tx_isolation;
    +-----------------+
    | @@tx_isolation  |
    +-----------------+
    | REPEATABLE-READ |
    +-----------------+


- RDBMSではクライアントからSQLを発行すると自動的にトランザクションが開始され、コミット/ロールバックされるまでトランザクションが継続する
- 多くのRDBMSにおいて「Auto-commit（自動コミット）」と呼ばれる機能がデフォルトでONになっており、SQLを1ステートメント実行するたびに自動的にコミットされてトランザクションは確定される
- トランザクションを制御するためには「Auto-commit」機能を無効にする必要がある

例）Globalの自動コミット設定の確認

    show global variables like 'autocommit';
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | autocommit    | ON    |
    +---------------+-------+

例）現在の接続セッションの自動コミット設定の確認

    show session variables like 'autocommit';
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | autocommit    | ON    |
    +---------------+-------+


    ※ `session` 句はデフォルトなので省略可


## トランザクション分離レベルの挙動確認とトランザクション制御
- このチュートリアル実行例では2つの異なるクライアント･セッションを使用
    - 現在使用しているクライアント（Git Bashもしくは他のターミナル）とは別に、もう1つクライアントを起動してMariaDBに接続

トランザクション制御を行うために現在の接続セッションの自動コミット設定をOFF

    set session autocommit = OFF;

確認

    show session variables like 'autocommit';
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | autocommit    | OFF   |
    +---------------+-------+

「lesson」データベースに作成した従業員テーブルのレコードをどちらか片方のセッション（仮にセッションAとする）で更新して結果を確認

例）セッションAでレコードの更新

    update employee set salary = 5000 where id = 1;

例）セッションAで結果を確認

    select salary from employee where id = 1;
    +--------+
    | salary |
    +--------+
    |   5000 |
    +--------+

Auto-commitがOFFになっており自動的にコミットされないため、トランザクションの更新結果は「未確定」の状態であるため、セッションAの更新内容はセッションBでは反映されない（Dirty Readが発生しない）。

セッションAとは別のセッション（仮にセッションBとする）で結果を確認 (変更は見えない)

例）セッションBでセッションAの更新内容を確認

    select salary from employee where id = 1;
    +--------+
    | salary |
    +--------+
    |   3100 |
    +--------+


![](https://paper-attachments.dropbox.com/s_97DB13A37AEFF282FDE7C8C407E2A651907B7247430185934EA45818D080342A_1559067805655_image.png)



- トランザクション制御を行っている場合には、更新内容のコミット/ロールバックは明示的にステートメントを発行する必要がある
    - コミット ･･･ `commit` ステートメント
    - ロールバック ･･･ `rollback` ステートメント

セッションAのトランザクションをコミット (確定)

    commit;

セッションBで再度確認 (変更が反映されている)

    > select * from employee where id = 1;
    +--------+
    | salary |
    +--------+
    |   5000 |
    +--------+


![](https://paper-attachments.dropbox.com/s_97DB13A37AEFF282FDE7C8C407E2A651907B7247430185934EA45818D080342A_1559068161185_image.png)



